# 의존성 그래프

번들링은 단순히 여러 파일을 하나로 묶는 작업이 아니에요.
실제로는 애플리케이션을 구성하는 모든 파일 간의 연결 관계를 분석하고, 그 관계를 정밀한 그래프 형태로 구성해 실행 가능한 하나의 흐름으로 만드는 과정이에요.
이 그래프를 우리는 의존성 그래프(Dependency Graph) 라고 불러요.

## 왜 번들러가 필요한가요?
현대 웹 애플리케이션은 수십, 수백 개의 모듈로 구성돼 있어요.
이 모듈들은 서로 복잡하게 얽혀 있고, 종종 동일한 패키지가 여러 위치에서 사용되거나, 서로 다른 경로로 import되기도 해요.

예를 들어: ../components/Button과 @/components/Button은 사실 같은 파일을 가리킬 수도 있어요.
lodash가 여러 버전으로 중복 설치되어 각각 다른 경로에서 참조되기도 해요.
A가 B를, B가 C를, C가 다시 A를 참조하는 순환 구조가 숨어 있을 수도 있어요.

이런 상황에서 단순히 “파일을 묶는다”는 접근만으로는 문제가 생기기 쉬워요.
정확하게 어떤 파일이 어떤 흐름으로 실행되고, 중복 없이 병합되어야 하는지를 파악하기 위해선 의존성 그래프가 필요해요.


## 의존성 그래프는 어떻게 만들어질까요?

1. 진입점에서 시작해요
의존성 그래프는 애플리케이션의 진입점(entry) 에서 시작해요.
번들러는 지정된 진입점 파일을 기준으로, import나 require를 따라 모든 모듈을 하나하나 따라가며 그래프를 확장해 나가요.

2. 모듈을 해석해요
모듈 간 연결을 정확하게 이해하려면, 번들러는 import된 경로가 실제로 어떤 파일을 가리키는지를 정확히 파악해야 해요.
이 과정을 모듈 해석(Module Resolution) 이라고 해요.

@/utils 같은 별칭을 어떤 경로로 바꿔야 할까요?

lodash라는 이름은 node_modules 어디에 위치한 어떤 버전일까요?

경로가 틀렸거나, 잘못된 의존성이 걸려 있지는 않을까요?

이 단계에서 번들러는 자체 해석 규칙을 기반으로 정확한 의존성을 파악하고, 중복되거나 순환된 연결을 안전하게 처리해줘요.
이것이 번들러가 단순한 파일 복사 도구와 다른 이유예요.

## 의존성 그래프를 만들면 무엇이 좋아지나요?
정확한 코드 포함 범위: 어떤 모듈을 포함할지, 어떤 건 제외할지를 구조적으로 판단할 수 있어요.

중복 제거: 동일한 모듈이 여러 번 번들되는 것을 방지해요.

순환 의존성 탐지: 빌드 오류나 실행 오류를 미리 방지할 수 있어요.

최적화 기반 제공: 트리 셰이킹, 코드 스플리팅 등은 의존성 그래프를 기반으로 작동해요.

## 마무리
번들링은 결국 의존성 그래프를 그리고, 그 그래프를 기반으로 최적의 실행 구조를 만드는 과정이에요.
이제부터 이어지는 문서에서는 이 그래프가 어떻게 확장되고, 어떤 설정이 그래프에 어떤 영향을 주는지를 하나씩 살펴보게 될 거예요.

다음 단계: 진입점과 출력에서는 그래프의 출발점이 어떻게 설정되는지를 알아봐요.

