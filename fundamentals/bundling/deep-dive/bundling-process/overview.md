# 번들링, 꼭 필요할까요?

프로젝트 규모가 커지면 모듈 간 연결 구조가 복잡해져요. 동일한 모듈이 여러 곳에서 반복 참조되거나, 순환 참조로 인해 실행 순서를 예측하기 어려운 상황이 발생해요. 브라우저에서 각 모듈을 개별적으로 불러올 경우, 이 모든 의존성을 직접 관리해야 해요.

모듈 구조를 명확히 정리하고 실행 흐름을 통합적으로 제어하려면, 구조 분석과 최적화가 필요해요. 이 작업을 자동으로 수행해주는 도구가 바로 번들러예요.

번들러는 모듈 간 연결 관계를 분석하고, 중복되거나 불필요한 코드를 제거하며, 실행 경로를 재구성해요. 그 결과, 브라우저는 필요한 코드만 안정적으로 불러와 실행할 수 있어요.

## 어떤 과정을 거쳐 번들링이 될까요?

번들링은 프로젝트의 실행 흐름을 재구성하는 작업이에요. 번들러는 코드의 연결 구조를 파악하고, 이를 하나의 파일로 묶어 브라우저가 효율적으로 실행할 수 있도록 도와줘요.

이 과정은 다음과 같은 단계로 이루어져요:

### 1. 모듈 탐색 (Module Resolution)

번들러는 진입점(entry point)부터 시작해, import나 require를 따라가며 연결된 모든 모듈을 탐색해요. 이 과정에서 애플리케이션 전체의 참조 구조를 파악할 수 있어요.

```javascript
// index.js
import { add } from './math.js';
console.log(add(2, 3));

// math.js
export function add(a, b) {
  return a + b;
}
```

### 2. 의존성 구조 정리

탐색한 모듈 간의 참조 정보를 바탕으로, 번들러는 전체 코드 흐름을 정리해요.
각 모듈이 어떤 다른 모듈에 의존하는지를 기록한 구조를 \*\*의존성 그래프(dependency graph)\*\*라고 해요.
이 그래프는 번들 파일을 구성할 때 기준이 되는 역할을 해요.

```javascript
{
  "index.js": {
    "dependencies": ["math.js"],
    "code": "console.log(add(2, 3));"
  },
  "math.js": {
    "dependencies": [],
    "code": "function add(a, b) { return a + b; }"
  }
}
```

### 3. 번들 파일 생성

마지막 단계에서는 정리된 의존 정보를 기반으로 필요한 모든 코드를 하나의 파일로 묶어요. 이 파일은 브라우저가 직접 여러 파일을 불러오지 않고도 한 번에 실행할 수 있도록 구성돼 있어요.

```javascript
(function(modules) {
  function require(file) {
    const exports = {};
    modules[file](exports, require);
    return exports;
  }

  require('index.js');
})({
  'index.js': function(exports, require) {
    const { add } = require('math.js');
    console.log(add(2, 3));
  },
  'math.js': function(exports) {
    exports.add = function(a, b) {
      return a + b;
    };
  }
});
```

모듈 간 구조를 정리하면, 브라우저는 직접 여러 파일을 로드하지 않고도 필요한 코드를 한 번에 불러올 수 있어요. 

:::details 💡 왜 즉시 실행 함수(IIFE)를 사용할까요?
1. **스코프를 분리할 수 있어요**
   IIFE는 자체 스코프를 가지기 때문에, 내부 변수나 함수가 전역 스코프를 오염시키지 않아요.

2. **모듈 시스템을 안전하게 구성할 수 있어요**
   `require` 함수나 `modules` 객체 같은 모듈 로딩 로직을 IIFE 내부에서 정의함으로써, 외부와 격리된 안전한 실행 환경을 만들 수 있어요.
:::


## 번들링이 가져오는 구조적 이점

번들링은 코드 실행의 안정성과 효율성을 높이는 데 핵심적인 역할을 해요. 규모가 큰 프로젝트일수록 중복된 코드, 복잡한 참조 관계, 불필요한 모듈이 쌓이면서 성능 저하와 예기치 못한 오류가 발생하기 쉬워요.
번들러는 이 문제들을 구조적으로 정리해, 코드를 더 **빠르고, 작고, 안정적으로** 실행할 수 있도록 도와줘요.

### ✅ 중복 코드 제거

동일한 함수나 라이브러리가 여러 번 포함되지 않도록 중복을 제거해요.
이를 통해 번들 크기를 줄이고, 브라우저의 네트워크 요청도 최소화할 수 있어요.

### 🔁 순환 참조 정리

얽혀 있는 모듈 간 참조 관계를 분석하고 재정리해요.
실행 순서를 예측 가능하게 만들어, 런타임 오류 발생 가능성을 줄여줘요.

### 🧹 미사용 코드 제거

사용되지 않는 함수나 모듈은 번들에 포함하지 않아요.
최종 파일 크기를 줄이는 동시에, 유지보수 비용도 낮출 수 있어요.


## 다음 단계
번들링은 “어디서부터 어떤 파일을 읽어야 할지”를 명확히 정하는 것에서 시작돼요.
이 출발점을 **진입점(Entry Point)**이라고 부르고, 번들러는 진입점을 기준으로 전체 모듈 구조를 따라가며 코드를 모아갑니다.

다음 문서에서는 이 진입점이 어떤 역할을 하고, 생성되는 번들 파일의 구성에 어떤 영향을 주는지 자세히 살펴볼게요.
