# 번들링, 꼭 필요할까요?

애플리케이션을 구성하는 모듈들이 어떻게 연결되어 있는지 분석하고,
불필요한 코드를 제거하고, 경로를 탐색하고, 모듈을 재구성해 실행 흐름을 명확히 만드는 과정이에요.

작은 프로젝트는 모듈 간 흐름이 단순해서 전체 구조를 쉽게 파악할 수 있어요.
하지만 프로젝트가 커지면, 같은 모듈이 여러 번 참조되거나 순환 참조가 발생해 실행 순서를 정확히 관리하기 어려워져요.

이런 복잡함을 해결하기 위해, 번들러는 모듈 간 연결 구조를 체계적으로 정리해요.
필요한 코드만 선택해 브라우저에서 안정적으로 실행할 수 있도록 흐름을 만들어줘요.
![](/images/bundling/dependency-graph.png)


## 어떤 과정을 거쳐 번들링이 될까요?

번들링의 핵심은 프로젝트에 필요한 코드를 정확히 식별하고 구조화하는 작업이에요.
이를 위해 번들러는 진입점에서 시작해, import나 require로 연결된 모듈을 따라가며 전체 코드를 탐색해요(Module Resolution).
이 과정을 통해 모듈 간 참조 구조를 파악하고, 이 정보를 기반으로 최종 번들 파일을 생성해요.

예를 들어 다음과 같은 코드가 있다고 가정해볼게요:
```javascript
// index.js (entry file)
import { add } from './math.js';
console.log(add(2, 3));

// math.js
export function add(a, b) {
  return a + b;
}
```

index.js는 math.js를 참조하고 있어요.
번들러는 index.js를 분석해 연결된 파일들을 탐색하고, 다음과 같이 객체 형태로 정리할 수 있어요:
```javascript
{
  "index.js": {
    "dependencies": ["math.js"],
    "code": "console.log(add(2, 3));"
  },
  "math.js": {
    "dependencies": [],
    "code": "function add(a, b) { return a + b; }"
  }
}
```

번들러는 의존성 정보를 바탕으로 브라우저에서 실행 가능한 번들 파일을 만들 수 있어요.

```javascript
(function(modules) {
  function require(file) {
    const exports = {};
    modules[file](exports, require);
    return exports;
  }

  require('index.js');
})({
  'index.js': function(exports, require) {
    const { add } = require('math.js');
    console.log(add(2, 3));
  },
  'math.js': function(exports) {
    exports.add = function(a, b) {
      return a + b;
    };
  }
});
```

모듈 간 관계를 정리하면, 브라우저가 직접 여러 파일을 로드하지 않고도, 필요한 모든 코드를 한 번에 불러올 수 있게 돼요.

## 어떤 문제를 해결하나요?
번들링은 코드 실행의 안정성과 효율성을 높이는 데 중요한 역할을 해요.
복잡한 프로젝트에서는 중복 코드, 참조 오류, 불필요한 모듈 같은 문제가 자주 발생해요.
번들러는 이 문제들을 구조적으로 정리해, 코드를 더 빠르고 안전하게 실행할 수 있도록 도와줘요.

- ❌ 중복 제거
  - 동일한 함수나 라이브러리가 여러 번 포함되지 않도록 정리해요. 번들 크기를 줄이고, 브라우저의 네트워크 요청을 최소화할 수 있어요.

- 🔄 순환 참조 방지
  - 얽혀 있는 모듈 간 참조 관계를 정리해, 실행 순서를 안정적으로 관리해요. 예상치 못한 런타임 오류를 줄일 수 있어요.

- 🗑 죽은 코드 제거
  - 실제로 필요하지 않은 코드를 번들에 포함하지 않아요. 최종 파일 크기를 줄이고, 유지보수를 더 쉽게 만들 수 있어요.


## 다음 단계
번들링은 “어디서부터 어떤 파일을 읽어야 할지”를 명확히 정하는 것에서 시작돼요.
이 출발점을 **진입점(Entry Point)**이라고 부르고, 번들러는 진입점을 기준으로 전체 모듈 구조를 따라가며 코드를 모아갑니다.

다음 문서에서는 이 진입점이 어떤 역할을 하고, 생성되는 번들 파일의 구성에 어떤 영향을 주는지 자세히 살펴볼게요.