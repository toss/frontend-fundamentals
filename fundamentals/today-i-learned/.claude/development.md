# 개발 원칙

## 핵심 철학

### 기본 신념

- **점진적 개선보다 큰 변화** - 컴파일되고 테스트를 통과하는 작은 변경사항
- **기존 코드에서 학습** - 구현 전에 연구하고 계획하기
- **교조적보다 실용적** - 프로젝트 현실에 맞게 적응
- **영리한 코드보다 명확한 의도** - 지루하고 명백한 솔루션 선택

### 단순함의 의미

- 함수/클래스당 단일 책임
- 성급한 추상화 피하기
- 영리한 트릭 금지 - 지루한 솔루션 선택
- 설명이 필요하다면 너무 복잡한 것

## 개발 프로세스

### 1. 계획 및 단계화

복잡한 작업을 3-5단계로 나누어 `IMPLEMENTATION_PLAN.md`에 문서화:

```markdown
## 단계 N: [이름]
**목표**: [구체적인 결과물]
**성공 기준**: [테스트 가능한 결과]
**테스트**: [구체적인 테스트 케이스]
**상태**: [시작 전|진행 중|완료]
```

- 진행하면서 상태를 업데이트
- 모든 단계 완료 시 파일 삭제

### 2. 구현 흐름

1. **이해** - 코드베이스의 기존 패턴 연구
2. **테스트** - 테스트 먼저 작성 (Red)
3. **구현** - 통과를 위한 최소 코드 (Green)
4. **리팩터** - 테스트 통과 상태에서 정리
5. **커밋** - 계획과 연결된 명확한 메시지

### 3. 막혔을 때 (3회 시도 후)

**중요**: 문제당 최대 3회 시도 후 중단.

1. **실패 내용 문서화**:
   - 시도한 것
   - 구체적인 에러 메시지
   - 실패 원인 추정

2. **대안 연구**:
   - 2-3개의 유사한 구현 찾기
   - 다른 접근 방식 기록

3. **기본기 질문**:
   - 올바른 추상화 레벨인가?
   - 더 작은 문제로 나눌 수 있는가?
   - 완전히 다른 간단한 접근법이 있는가?

4. **다른 각도 시도**:
   - 다른 라이브러리/프레임워크 기능?
   - 다른 아키텍처 패턴?
   - 추상화 추가 대신 제거?

## 기술 표준

### 코드 품질

**모든 커밋은 반드시**:

- 성공적으로 컴파일
- 모든 기존 테스트 통과
- 새 기능에 대한 테스트 포함
- 프로젝트 포맷팅/린팅 준수

**커밋 전에**:

- 포맷터/린터 실행
- 변경사항 자체 검토
- 커밋 메시지에 "왜"를 설명

## 프론트엔드 개발 흐름

1. **이해** - 코드베이스의 기존 패턴 연구
2. **구현** - 기능 구현 (UI/UX 우선)
3. **검증** - 수동 테스트 및 브라우저 확인
4. **테스트** - 핵심 로직에 대한 테스트 추가
5. **리팩터** - 코드 정리 및 최적화
6. **커밋** - 계획과 연결된 명확한 메시지

## 테스트 전략 (프론트엔드 특화)

### 테스트 우선순위

1. **핵심 비즈니스 로직** - 유틸리티 함수, 커스텀 훅의 데이터 변환 로직
2. **API 통합** - React Query 훅들의 에러 처리와 데이터 변환
3. **사용자 인터랙션** - 중요한 버튼 클릭, 폼 제출 등
4. **UI 컴포넌트** - 간단한 렌더링 테스트 (선택적)

### 실용적 테스트 가이드라인

- **UI는 가벼운 테스트** - 복잡한 UI 테스트 대신 TypeScript와 ESLint 활용
- **로직 위주 테스트** - 순수 함수, 커스텀 훅의 핵심 로직 집중
- **E2E는 핵심 플로우만** - 로그인, 주요 사용자 여정
- **시각적 검증은 수동** - Storybook이나 브라우저에서 직접 확인

### 명령어

- 테스트 실행: `npm test`
- 타입 체크: `npm run typecheck`
- 린트: `npm run lint`
- 빌드: `npm run build`

### 완료 정의

- [ ] 핵심 로직 테스트 작성 및 통과
- [ ] 타입 체크 통과
- [ ] 린터/포매터 경고 없음
- [ ] 브라우저에서 기능 동작 확인
- [ ] 커밋 메시지가 명확함
- [ ] 구현이 계획과 일치
- [ ] 이슈 번호 없는 TODO 없음

## API 규칙

### 데이터 페칭

- React Query를 사용한 서버 상태 관리
- 커스텀 hooks로 API 로직을 분리합니다
- 로딩, 에러 상태를 일관되게 처리합니다

### GitHub API 연동

- GraphQL API를 사용합니다
- 인증은 GitHub OAuth를 통해 처리합니다
- Rate limiting을 고려한 요청 처리

### 에러 처리

- Error Boundary로 컴포넌트 레벨 에러 처리
- Toast로 사용자 피드백 제공
- 의미 있는 에러 메시지 표시

### 타입 안전성

- API 응답에 대한 명확한 타입 정의
- Zod 등을 사용한 런타임 유효성 검증
- 타입스크립트 strict 모드 준수

### React Query 패턴

- 커스텀 훅으로 API 로직 캡슐화
- 로딩과 에러 상태 일관된 처리
- 캐시 키 네이밍 컨벤션 따르기
- 낙관적 업데이트 적절히 활용

### GitHub API 통합

- GraphQL 쿼리 최적화
- 인증 토큰 안전한 관리
- Rate limiting 고려한 요청 처리
- 에러 응답 적절한 핸들링

## 중요한 알림

**절대 하지 말 것**:

- `--no-verify`로 커밋 훅 우회
- 테스트 수정 대신 비활성화
- 컴파일되지 않는 코드 커밋
- 가정하기 - 기존 코드로 확인

**항상 할 것**:

- 작동하는 코드를 점진적으로 커밋
- 진행하면서 계획 문서 업데이트
- 기존 구현에서 학습
- 3회 실패 후 중단하고 재평가
