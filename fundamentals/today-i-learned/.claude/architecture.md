# 아키텍처 및 설계 원칙

## 핵심 아키텍처 원칙

- **합성보다 상속** - 의존성 주입 사용
- **싱글톤보다 인터페이스** - 테스트와 유연성 확보
- **암시적보다 명시적** - 명확한 데이터 흐름과 의존성
- **가능한 한 테스트 주도** - 테스트 비활성화 대신 수정

## 의사결정 프레임워크

여러 유효한 접근법이 있을 때 다음 기준으로 선택:

1. **테스트 용이성** - 쉽게 테스트할 수 있는가?
2. **가독성** - 6개월 후에도 누군가 이해할 수 있는가?
3. **일관성** - 프로젝트 패턴과 일치하는가?
4. **단순성** - 작동하는 가장 간단한 솔루션인가?
5. **가역성** - 나중에 변경하기 얼마나 어려운가?

## 단순성 원칙

- 함수/컴포넌트당 단일 책임
- 성급한 추상화 피하기
- 영리한 트릭 금지 - 지루한 솔루션 선택
- 설명이 필요하다면 너무 복잡한 것

## 코드베이스 통합

### 기존 패턴 학습

- 3개의 유사한 기능/컴포넌트 찾기
- 공통 패턴과 컨벤션 식별
- 가능한 한 동일한 라이브러리/유틸리티 사용
- 기존 테스트 패턴 따르기

### 프로젝트별 패턴

- `src/components`의 기능별 분류 구조 따르기
- `src/hooks`의 커스텀 훅 패턴 활용
- `src/api`의 레이어 분리 구조 준수
- `src/types`의 타입 정의 방식 준수

### API 레이어 아키텍처

**3계층 분리 원칙:**

1. **GraphQL/Client 계층** (`src/api/graphql/`, `src/api/client.ts`)
   - 순수 쿼리/뮤테이션 정의
   - HTTP 클라이언트 설정

2. **비즈니스 로직 계층** (`src/api/remote/`)
   - API 함수들 + 도메인 타입
   - 데이터 변환 및 에러 처리
   - GitHub API 원본 응답 활용

3. **React Query 계층** (`src/api/hooks/`)
   - 캐싱, 무효화, 상태 관리
   - 컴포넌트에서 사용할 간단한 인터페이스 제공

**Query Key 관리:**

- 중앙 집중화된 Query Keys (`DISCUSSIONS_QUERY_KEYS`)
- 계층적 구조로 무효화 최적화

## 에러 처리 원칙

- 설명적인 메시지로 빠른 실패
- 디버깅을 위한 컨텍스트 포함
- 적절한 레벨에서 에러 처리
- 예외를 조용히 삼키지 않기
