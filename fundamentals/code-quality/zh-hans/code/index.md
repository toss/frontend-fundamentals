---
comments: false
---

# 编写优秀代码的四大原则

好的前端代码是**易于修改的**代码。
在实现新需求时，能够轻松修改和部署的代码被认为好的代码。
你可以根据四个标准判断代码是否易于修改。

## 1. 可读性

**可读性**(Readability)指的是代码易于阅读和理解的程度。
要使代码易于修改，首先必须理解代码的作用。

易于阅读的代码要求读者考虑的上下文较少，从上到下自然流畅。

### 提高可读性的策略

- **减少语境**
  - [分离不一起运行的代码](./examples/submit-button.md)
  - [抽象实现细节](./examples/login-start-page.md)
  - [根据逻辑类型拆分合并的函数](./examples/use-page-state-readability.md)
- **命名**
  - [为复杂条件命名](./examples/condition-name.md)
  - [为魔数命名](./examples/magic-number-readability.md)
- **使其从上到下顺利阅读**
  - [减少视点转移](./examples/user-policy.md)
  - [简化三元运算符](./examples/ternary-operator.md)

## 2. 可预测性

**可预测性**(Predictability)指的是与团队成员协作时，同事能够预测函数或组件行为的难易程度。
可预测性高的代码遵循一致的规则，仅通过函数或组件的名称、参数、返回值，就能知道其执行的行为。

### 提高可预测性的战略

- [避免命名重复](./examples/http.md)
- [统一同类函数的返回类型](./examples/use-user.md)
- [揭示隐藏的逻辑](./examples/hidden-logic.md)

## 3. 内聚性

**内聚性**(Cohesion)是指需要被修改的代码是否总是一起修改的特性。
内聚性高的代码，即使修改了某一部分，也不会在其他部分引发障碍。
这是因为在结构上保证了相关代码能够同步修改。

::: info 可读性与内聚性可能存在冲突

一般来说，为了提高内聚性，可能需要做出一些降低可读性的决策，例如抽象化变数或函数。
以内聚性为准，通过代码的通用化和抽象化来避免未同时修改而引发的障碍。
风险较低时，应优先考虑可读性，允许代码重复。

:::

### 提高内聚性的策略

- [需同时修改的文件位于同一目录下](./examples/code-directory.md)
- [消除魔数](./examples/magic-number-cohesion.md)
- [考虑表单的内聚性](./examples/form-fields.md)

## 4. 耦合性

**耦合性**(Coupling)是指修改代码时的影响范围。
易于修改的代码被修改时影响范围小，因此更容易预测更改的范围。

### 降低耦合性的策略

- [单独管理责任](./examples/use-page-state-coupling.md)
- [允许重复代码](./examples/use-bottom-sheet.md)
- [消除 Props Drilling](./examples/item-edit-modal.md)

## 多角度审视代码质量

遗憾的是，这四个标准很难同时兼顾。

例如，通过通用化和抽象化提高代码的内聚性，可确保函数或变数总是一同修改。然而，代码进一步抽象化后，可读性也会随之降低。

允许代码重复，可以减少代码的影响范围，从而降低耦合性。然而，这也可能导致在修改一处代码时，另一处未被及时修改，从而降低内聚性。

前端开发者需要结合当前面临的具体情况，深入思考并在不同价值之间权衡取舍，以确保代码在长期内更易于维护和修改。
